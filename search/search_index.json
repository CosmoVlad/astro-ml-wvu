{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>This is a collection of Jupyter notebooks from machine-learning (ML) coworking sessions held by the members of Prof. Sean McWilliam's group at West Virginia University.  Participants (alphabetical): - Anuj Kankani, - Jordan O'Kelley, - Matthew Cerep, - Sean McWilliams, - Siddharth Mahesh, - Suchindram Dasgupta, - Vladimir Strokov (discussion leader).</p> <p>The .py files are jupytext versions of Jupyter notebooks. <code>jupytext</code> prevents Git from tracking any changes in outputs of a notebook and can be installed together with other necessary packages (see below).  - to open a jupytext-enabled .py file, right-click on it in a Jupyter server and choose Open With -&gt; Notebook; - to generate a .py version of a new notebook, choose File -&gt; Jupytext -&gt; Pair Notebook with Percent Format (the Jupytext menu should be there if <code>jupytext</code> has been installed).</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#resources-about-machine-learning-ml","title":"Resources about machine learning (ML)","text":"<p>Some ways to get started with ML: - Coursera:   - Andrew Ng's courses/specializations, e.g. Machine Learning, Neural Networks and Deep Learning, Improving Deep Neural Networks: Hyperparameter Tuning, Regularization and Optimization.   - DeepLearning.ai - YouTube:   - e.g. TensorFlow tutorials - Books:   - e.g. About keras and tensorflow (keras is now a part of tensorflow)   - Fran\u00e7ois Chollet's Deep Learning with Python</p>"},{"location":"#preparing-a-python-environment","title":"Preparing a python environment","text":"<p>Different projects may require different sets of python packages with different versions. A good practice is to confine each project to its own python environment. It is also helpful that any software issues within an environment do not affect the system-wide python installation. That is, what happens in a python environment stays in the python environment.</p>"},{"location":"#linuxmac","title":"Linux/Mac","text":"<p>To create an environment with some name (I use testml below) in a directory: </p> <pre><code>cd directory/\npython3 -m venv testml\n</code></pre> <p>To activate the environment and install a set of basic packages inside it:</p> <pre><code>source testml/bin/activate\npip install --upgrade pip\npip install --upgrade setuptools\npip install numpy scipy matplotlib jupyter jupytext\n</code></pre> <p>To launch a <code>jupyter</code> notebook from within the environment:</p> <pre><code>jupyter-notebook\n</code></pre> <p>To deactivate the environment:</p> <pre><code>deactivate\n</code></pre>"},{"location":"#windows","title":"Windows","text":"<ol> <li>To create a venv:</li> </ol> <pre><code>python -m venv C:\\path\\to\\new\\virtual\\environment\n</code></pre> <p>For example, if we want to create a venv called testml in the current location,</p> <pre><code>python -m venv testml\n</code></pre> <ol> <li>To activate the venv:</li> </ol> <pre><code>C:\\path\\to\\new\\virtual\\environment\\Scripts\\activate\n</code></pre> <p>To activate the venv from our previous example,</p> <pre><code>testml\\Scripts\\activate\n</code></pre> <p>When the venv is activated, its name appears in the beginning of the command line:</p> <pre><code>(testml) C:\\&gt;\n</code></pre> <ol> <li>To install packages,</li> </ol> <pre><code>python -m pip install --upgrade pip\npython -m pip install numpy scipy matplotlib jupyter jupytext\n</code></pre> <ul> <li>Any additional packages can be installed by using <code>python -m pip install</code> followed by the name of a package.</li> <li>To launch a jupyter notebook,</li> </ul> <pre><code>jupyter notebook\n</code></pre> <p>If that doesn't work, try</p> <pre><code>python -m notebook\n</code></pre> <ol> <li>To deactivate the venv,</li> </ol> <pre><code>deactivate\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.Fblock","title":"<code>Fblock</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Feedforward block with three dense layers.</p> Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>class Fblock(keras.layers.Layer):\n    \"\"\"Feedforward block with three dense layers.\"\"\"\n\n    def __init__(self, units_list: List[int]) -&gt; None:\n        \"\"\"Initializes the Fblock layer.\n\n        Args:\n            units_list (List[int]): List of three integers specifying the number of units in each dense layer.\n        \"\"\"\n        super().__init__()\n        if len(units_list) != 3:\n            raise ValueError(\"units_list must have exactly three elements.\")\n        self.units_list = units_list\n        self.dense1 = layers.Dense(units_list[0], activation='tanh',kernel_initializer='zeros')\n        self.dense2 = layers.Dense(units_list[1], activation='tanh',kernel_initializer='zeros')\n        self.dense3 = layers.Dense(units_list[2], activation='tanh',kernel_initializer='zeros')\n\n    def call(self, input_tensor: tf.Tensor, training: bool = False) -&gt; tf.Tensor:\n        \"\"\"Forward pass for the Fblock layer.\n\n        Args:\n            input_tensor (tf.Tensor): Input tensor.\n            training (bool, optional): Whether in training mode. Defaults to False.\n\n        Returns:\n            tf.Tensor: Output tensor after passing through the three dense layers.\n        \"\"\"\n\n        phi,chi,p,e = tf.unstack(input_tensor, axis=-1)\n        #since chi is an angle, the prediction of chi + 2*np.pi will be the same.\n        true_input_tensor = tf.transpose(tf.convert_to_tensor([tf.math.cos(chi),p,e]))\n        x = self.dense1(true_input_tensor)\n        x = self.dense2(x)\n        x = self.dense3(x)\n        if self.units_list[-1] == 2:\n            # x has shape (batch_size,2), need to give it (batch_size,4) with zeros\n            phidot , chidot = tf.unstack(x, axis=-1)\n            xzero = tf.zeros_like(phidot)\n            x = tf.stack([phidot , chidot , xzero , xzero],axis=-1)\n        return x\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.Fblock.__init__","title":"<code>__init__(units_list)</code>","text":"<p>Initializes the Fblock layer.</p> <p>Parameters:</p> Name Type Description Default <code>units_list</code> <code>List[int]</code> <p>List of three integers specifying the number of units in each dense layer.</p> required Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>def __init__(self, units_list: List[int]) -&gt; None:\n    \"\"\"Initializes the Fblock layer.\n\n    Args:\n        units_list (List[int]): List of three integers specifying the number of units in each dense layer.\n    \"\"\"\n    super().__init__()\n    if len(units_list) != 3:\n        raise ValueError(\"units_list must have exactly three elements.\")\n    self.units_list = units_list\n    self.dense1 = layers.Dense(units_list[0], activation='tanh',kernel_initializer='zeros')\n    self.dense2 = layers.Dense(units_list[1], activation='tanh',kernel_initializer='zeros')\n    self.dense3 = layers.Dense(units_list[2], activation='tanh',kernel_initializer='zeros')\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.Fblock.call","title":"<code>call(input_tensor, training=False)</code>","text":"<p>Forward pass for the Fblock layer.</p> <p>Parameters:</p> Name Type Description Default <code>input_tensor</code> <code>Tensor</code> <p>Input tensor.</p> required <code>training</code> <code>bool</code> <p>Whether in training mode. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: Output tensor after passing through the three dense layers.</p> Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>def call(self, input_tensor: tf.Tensor, training: bool = False) -&gt; tf.Tensor:\n    \"\"\"Forward pass for the Fblock layer.\n\n    Args:\n        input_tensor (tf.Tensor): Input tensor.\n        training (bool, optional): Whether in training mode. Defaults to False.\n\n    Returns:\n        tf.Tensor: Output tensor after passing through the three dense layers.\n    \"\"\"\n\n    phi,chi,p,e = tf.unstack(input_tensor, axis=-1)\n    #since chi is an angle, the prediction of chi + 2*np.pi will be the same.\n    true_input_tensor = tf.transpose(tf.convert_to_tensor([tf.math.cos(chi),p,e]))\n    x = self.dense1(true_input_tensor)\n    x = self.dense2(x)\n    x = self.dense3(x)\n    if self.units_list[-1] == 2:\n        # x has shape (batch_size,2), need to give it (batch_size,4) with zeros\n        phidot , chidot = tf.unstack(x, axis=-1)\n        xzero = tf.zeros_like(phidot)\n        x = tf.stack([phidot , chidot , xzero , xzero],axis=-1)\n    return x\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.UDE","title":"<code>UDE</code>","text":"<p>               Bases: <code>Model</code></p> <p>Neural network-based universal differential equation solver.</p> Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>class UDE(keras.Model):\n    \"\"\"Neural network-based universal differential equation solver.\"\"\"\n\n    def __init__(\n        self,\n        partial_units_list: List[int],\n        num_step: int,\n        timestep: float,\n        q: float,\n        mean: float,\n        stdev: float,\n        use_real: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Initializes the UDE model.\n\n        Args:\n            partial_units_list (List[int]): Hidden layer sizes for Fblock.\n            num_step (int): Number of integration steps.\n            timestep (float): Time step for numerical integration.\n            q (float): Mass ratio given by m_smaller/m_larger.\n            mean (float): Global mean of the waveform.\n            stdev (float): Global standard deviation of the waveform.\n            use_real (bool, optional): Whether to use real part of the waveform. Defaults to True.\n            **kwargs: Additional arguments for keras.Model.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.timestep = timestep\n        self.num_step = num_step\n        self.q = q\n        self.mean = mean\n        self.stdev = stdev\n        self.use_real = use_real\n        self.udecell = UDEcell(partial_units_list, timestep, q)\n\n    def call(self, init_conditions_tensor: tf.Tensor, training: bool = False) -&gt; tf.Tensor:\n        \"\"\"Integrate UDE and returns the waveform.\n\n        Args:\n            init_conditions_tensor (tf.Tensor): Initial condition tensor.\n            training (bool, optional): Whether in training mode. Defaults to False.\n\n        Returns:\n            tf.Tensor: Normalized waveform data.\n        \"\"\"\n        y = init_conditions_tensor\n        sol = [y]\n        for _ in range(1,self.num_step):\n            dy = self.udecell(y, training=training)\n            y += dy\n            sol.append(y)\n        sol = tf.convert_to_tensor(sol)\n        self.sol = sol\n        #phi, chi, p, e = tf.unstack(sol, axis=-1)\n\n\n        waveform = self.h22(sol)\n        if self.use_real:\n            real_part = tf.math.real(waveform)\n            return tf.transpose((real_part - self.mean) / self.stdev)\n        imag_part = tf.math.imag(waveform)\n        return tf.transpose((imag_part - self.mean) / self.stdev)\n\n    def h22(\n        self,\n        dynamics: tf.Tensor\n    ) -&gt; tf.Tensor:\n        \"\"\"Compute the waveform.\n\n        Args:\n            dynamics (tf.Tensor): Batch of integrated UDE solutions.\n\n        Returns:\n            tf.Tensor: Normalized batch of strains (real part if self.use_real is True, complex otherwise).\n        \"\"\"\n\n        phi,chi,p,e = tf.unstack(dynamics, axis=-1)\n        r = p / (1 + e*tf.math.cos(chi))\n        x1 = r * self.q/(1+self.q) * tf.math.cos(phi)\n        y1 = r * self.q/(1+self.q) * tf.math.sin(phi)\n        x2 = -r * 1/(1+self.q) * tf.math.cos(phi)\n        y2 = -r * 1/(1+self.q) * tf.math.sin(phi)\n        Ixx = x1**2 + self.q*x2**2\n        Iyy = y1**2 + self.q*y2**2\n        Ixy = x1*y1 + self.q*x2*y2\n        trace = Ixx + Iyy\n        r = p / (1 + e*tf.math.cos(chi))\n        Jxx = Ixx - trace/3\n        Jyy = Iyy - trace/3\n        ddJxx = (Jxx[2:] - 2*Jxx[1:-1] + Jxx[:-2]) / self.timestep**2\n        ddJyy = (Jyy[2:] - 2*Jyy[1:-1] + Jyy[:-2]) / self.timestep**2\n        const = 1/r[1:-1] * tf.math.sqrt(4*np.pi/5)\n        real_part = const * (ddJxx - ddJyy)\n        if self.use_real:\n            return real_part\n        Jxy = Ixy\n        ddJxy = (Jxy[2:] - 2*Jxy[1:-1] + Jxy[:-2]) / self.timestep**2\n        imag_part = const * (- 2*ddJxy)\n        return tf.complex(real_part, imag_part)\n\n    def change_num_step(\n        self,\n        num_step: float,\n    ) -&gt; None:\n        \"\"\"\n        Change the number of timesteps over which RK integration is done.\n\n        Args:\n            num_step (float): Number of timesteps.\n        \"\"\"\n        self.num_step = num_step\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.UDE.__init__","title":"<code>__init__(partial_units_list, num_step, timestep, q, mean, stdev, use_real=True, **kwargs)</code>","text":"<p>Initializes the UDE model.</p> <p>Parameters:</p> Name Type Description Default <code>partial_units_list</code> <code>List[int]</code> <p>Hidden layer sizes for Fblock.</p> required <code>num_step</code> <code>int</code> <p>Number of integration steps.</p> required <code>timestep</code> <code>float</code> <p>Time step for numerical integration.</p> required <code>q</code> <code>float</code> <p>Mass ratio given by m_smaller/m_larger.</p> required <code>mean</code> <code>float</code> <p>Global mean of the waveform.</p> required <code>stdev</code> <code>float</code> <p>Global standard deviation of the waveform.</p> required <code>use_real</code> <code>bool</code> <p>Whether to use real part of the waveform. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments for keras.Model.</p> <code>{}</code> Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>def __init__(\n    self,\n    partial_units_list: List[int],\n    num_step: int,\n    timestep: float,\n    q: float,\n    mean: float,\n    stdev: float,\n    use_real: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initializes the UDE model.\n\n    Args:\n        partial_units_list (List[int]): Hidden layer sizes for Fblock.\n        num_step (int): Number of integration steps.\n        timestep (float): Time step for numerical integration.\n        q (float): Mass ratio given by m_smaller/m_larger.\n        mean (float): Global mean of the waveform.\n        stdev (float): Global standard deviation of the waveform.\n        use_real (bool, optional): Whether to use real part of the waveform. Defaults to True.\n        **kwargs: Additional arguments for keras.Model.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.timestep = timestep\n    self.num_step = num_step\n    self.q = q\n    self.mean = mean\n    self.stdev = stdev\n    self.use_real = use_real\n    self.udecell = UDEcell(partial_units_list, timestep, q)\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.UDE.call","title":"<code>call(init_conditions_tensor, training=False)</code>","text":"<p>Integrate UDE and returns the waveform.</p> <p>Parameters:</p> Name Type Description Default <code>init_conditions_tensor</code> <code>Tensor</code> <p>Initial condition tensor.</p> required <code>training</code> <code>bool</code> <p>Whether in training mode. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: Normalized waveform data.</p> Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>def call(self, init_conditions_tensor: tf.Tensor, training: bool = False) -&gt; tf.Tensor:\n    \"\"\"Integrate UDE and returns the waveform.\n\n    Args:\n        init_conditions_tensor (tf.Tensor): Initial condition tensor.\n        training (bool, optional): Whether in training mode. Defaults to False.\n\n    Returns:\n        tf.Tensor: Normalized waveform data.\n    \"\"\"\n    y = init_conditions_tensor\n    sol = [y]\n    for _ in range(1,self.num_step):\n        dy = self.udecell(y, training=training)\n        y += dy\n        sol.append(y)\n    sol = tf.convert_to_tensor(sol)\n    self.sol = sol\n    #phi, chi, p, e = tf.unstack(sol, axis=-1)\n\n\n    waveform = self.h22(sol)\n    if self.use_real:\n        real_part = tf.math.real(waveform)\n        return tf.transpose((real_part - self.mean) / self.stdev)\n    imag_part = tf.math.imag(waveform)\n    return tf.transpose((imag_part - self.mean) / self.stdev)\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.UDE.change_num_step","title":"<code>change_num_step(num_step)</code>","text":"<p>Change the number of timesteps over which RK integration is done.</p> <p>Parameters:</p> Name Type Description Default <code>num_step</code> <code>float</code> <p>Number of timesteps.</p> required Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>def change_num_step(\n    self,\n    num_step: float,\n) -&gt; None:\n    \"\"\"\n    Change the number of timesteps over which RK integration is done.\n\n    Args:\n        num_step (float): Number of timesteps.\n    \"\"\"\n    self.num_step = num_step\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.UDE.h22","title":"<code>h22(dynamics)</code>","text":"<p>Compute the waveform.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>Tensor</code> <p>Batch of integrated UDE solutions.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: Normalized batch of strains (real part if self.use_real is True, complex otherwise).</p> Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>def h22(\n    self,\n    dynamics: tf.Tensor\n) -&gt; tf.Tensor:\n    \"\"\"Compute the waveform.\n\n    Args:\n        dynamics (tf.Tensor): Batch of integrated UDE solutions.\n\n    Returns:\n        tf.Tensor: Normalized batch of strains (real part if self.use_real is True, complex otherwise).\n    \"\"\"\n\n    phi,chi,p,e = tf.unstack(dynamics, axis=-1)\n    r = p / (1 + e*tf.math.cos(chi))\n    x1 = r * self.q/(1+self.q) * tf.math.cos(phi)\n    y1 = r * self.q/(1+self.q) * tf.math.sin(phi)\n    x2 = -r * 1/(1+self.q) * tf.math.cos(phi)\n    y2 = -r * 1/(1+self.q) * tf.math.sin(phi)\n    Ixx = x1**2 + self.q*x2**2\n    Iyy = y1**2 + self.q*y2**2\n    Ixy = x1*y1 + self.q*x2*y2\n    trace = Ixx + Iyy\n    r = p / (1 + e*tf.math.cos(chi))\n    Jxx = Ixx - trace/3\n    Jyy = Iyy - trace/3\n    ddJxx = (Jxx[2:] - 2*Jxx[1:-1] + Jxx[:-2]) / self.timestep**2\n    ddJyy = (Jyy[2:] - 2*Jyy[1:-1] + Jyy[:-2]) / self.timestep**2\n    const = 1/r[1:-1] * tf.math.sqrt(4*np.pi/5)\n    real_part = const * (ddJxx - ddJyy)\n    if self.use_real:\n        return real_part\n    Jxy = Ixy\n    ddJxy = (Jxy[2:] - 2*Jxy[1:-1] + Jxy[:-2]) / self.timestep**2\n    imag_part = const * (- 2*ddJxy)\n    return tf.complex(real_part, imag_part)\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.UDEcell","title":"<code>UDEcell</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Runge-Kutta single-step evolver for neural network-based ODEs.</p> Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>class UDEcell(keras.layers.Layer):\n    \"\"\"Runge-Kutta single-step evolver for neural network-based ODEs.\"\"\"\n\n    def __init__(self, partial_units_list: List[int], timestep: float, q: float) -&gt; None:\n        \"\"\"Initializes the UDEcell layer.\n\n        Args:\n            partial_units_list (List[int]): List of integers specifying the hidden layer sizes.\n            timestep (float): Time step for numerical integration.\n            q (float): Mass ratio of the system.\n        \"\"\"\n        super().__init__()\n        self.timestep = timestep\n        self.partial_units_list = partial_units_list\n        self.q = q\n\n    def build(self, input_shape: tf.TensorShape) -&gt; None:\n        \"\"\"Builds the Fblock using the input shape.\n\n        Args:\n            input_shape (tf.TensorShape): Shape of the input tensor.\n        \"\"\"\n        #testing purely to evolve chi and phi\n        units_list = [*self.partial_units_list, 2]\n        #units_list = [*self.partial_units_list, 4]\n        self.fblock = Fblock(units_list)\n\n    def call(self, input_tensor: tf.Tensor, training: bool = False) -&gt; tf.Tensor:\n        \"\"\"Forward pass for UDEcell using a Runge-Kutta solver.\n\n        Args:\n            input_tensor (tf.Tensor): Input batch of primitive variables.\n            training (bool, optional): Whether in training mode. Defaults to False.\n\n        Returns:\n            tf.Tensor: Batch of primitive variables numerically evolved by one timestep.\n        \"\"\"\n\n        k1 = self.fiducial_rhs(input_tensor)\n        k2 = self.fiducial_rhs(input_tensor + self.timestep * k1 / 2.0)\n        k3 = self.fiducial_rhs(input_tensor + self.timestep * k2 / 2.0)\n        k4 = self.fiducial_rhs(input_tensor + self.timestep * k3)\n        dy = self.timestep / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n        k1 = self.fblock(input_tensor)\n        k2 = self.fblock(input_tensor + self.timestep * k1 / 2.0)\n        k3 = self.fblock(input_tensor + self.timestep * k2 / 2.0)\n        k4 = self.fblock(input_tensor + self.timestep * k3)\n        dy_correction = self.timestep / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n        return dy + dy_correction\n    #Todo: use a decorator so that it can be called outside of the class! \n    def fiducial_rhs(self,y: tf.Tensor) -&gt; tf.Tensor:\n        \"\"\"Fiducial(Newtonian) right hand side for UDE.\n\n        Args:\n            y (tf.Tensor): Input batch of primitive variables.\n\n        Returns:\n            tf.Tensor: Output batch of Newtonian right hand sides\n        \"\"\"\n        phi,chi,p,e = tf.unstack(y, axis=-1)\n        phi_dot = (1 + e*tf.math.cos(chi))**2 / p**1.5\n        chi_dot = (1 + e*tf.math.cos(chi))**2 / p**1.5\n        p_dot = tf.zeros(tf.shape(phi_dot))\n        e_dot = tf.zeros(tf.shape(phi_dot))\n        return tf.transpose(tf.convert_to_tensor([phi_dot,chi_dot,p_dot,e_dot]))\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.UDEcell.__init__","title":"<code>__init__(partial_units_list, timestep, q)</code>","text":"<p>Initializes the UDEcell layer.</p> <p>Parameters:</p> Name Type Description Default <code>partial_units_list</code> <code>List[int]</code> <p>List of integers specifying the hidden layer sizes.</p> required <code>timestep</code> <code>float</code> <p>Time step for numerical integration.</p> required <code>q</code> <code>float</code> <p>Mass ratio of the system.</p> required Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>def __init__(self, partial_units_list: List[int], timestep: float, q: float) -&gt; None:\n    \"\"\"Initializes the UDEcell layer.\n\n    Args:\n        partial_units_list (List[int]): List of integers specifying the hidden layer sizes.\n        timestep (float): Time step for numerical integration.\n        q (float): Mass ratio of the system.\n    \"\"\"\n    super().__init__()\n    self.timestep = timestep\n    self.partial_units_list = partial_units_list\n    self.q = q\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.UDEcell.build","title":"<code>build(input_shape)</code>","text":"<p>Builds the Fblock using the input shape.</p> <p>Parameters:</p> Name Type Description Default <code>input_shape</code> <code>TensorShape</code> <p>Shape of the input tensor.</p> required Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>def build(self, input_shape: tf.TensorShape) -&gt; None:\n    \"\"\"Builds the Fblock using the input shape.\n\n    Args:\n        input_shape (tf.TensorShape): Shape of the input tensor.\n    \"\"\"\n    #testing purely to evolve chi and phi\n    units_list = [*self.partial_units_list, 2]\n    #units_list = [*self.partial_units_list, 4]\n    self.fblock = Fblock(units_list)\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.UDEcell.call","title":"<code>call(input_tensor, training=False)</code>","text":"<p>Forward pass for UDEcell using a Runge-Kutta solver.</p> <p>Parameters:</p> Name Type Description Default <code>input_tensor</code> <code>Tensor</code> <p>Input batch of primitive variables.</p> required <code>training</code> <code>bool</code> <p>Whether in training mode. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: Batch of primitive variables numerically evolved by one timestep.</p> Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>def call(self, input_tensor: tf.Tensor, training: bool = False) -&gt; tf.Tensor:\n    \"\"\"Forward pass for UDEcell using a Runge-Kutta solver.\n\n    Args:\n        input_tensor (tf.Tensor): Input batch of primitive variables.\n        training (bool, optional): Whether in training mode. Defaults to False.\n\n    Returns:\n        tf.Tensor: Batch of primitive variables numerically evolved by one timestep.\n    \"\"\"\n\n    k1 = self.fiducial_rhs(input_tensor)\n    k2 = self.fiducial_rhs(input_tensor + self.timestep * k1 / 2.0)\n    k3 = self.fiducial_rhs(input_tensor + self.timestep * k2 / 2.0)\n    k4 = self.fiducial_rhs(input_tensor + self.timestep * k3)\n    dy = self.timestep / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    k1 = self.fblock(input_tensor)\n    k2 = self.fblock(input_tensor + self.timestep * k1 / 2.0)\n    k3 = self.fblock(input_tensor + self.timestep * k2 / 2.0)\n    k4 = self.fblock(input_tensor + self.timestep * k3)\n    dy_correction = self.timestep / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    return dy + dy_correction\n</code></pre>"},{"location":"api/#Orbital_Dynamics.UDE_model_experimental.UDEcell.fiducial_rhs","title":"<code>fiducial_rhs(y)</code>","text":"<p>Fiducial(Newtonian) right hand side for UDE.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>Tensor</code> <p>Input batch of primitive variables.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>tf.Tensor: Output batch of Newtonian right hand sides</p> Source code in <code>Orbital_Dynamics/UDE_model_experimental.py</code> <pre><code>def fiducial_rhs(self,y: tf.Tensor) -&gt; tf.Tensor:\n    \"\"\"Fiducial(Newtonian) right hand side for UDE.\n\n    Args:\n        y (tf.Tensor): Input batch of primitive variables.\n\n    Returns:\n        tf.Tensor: Output batch of Newtonian right hand sides\n    \"\"\"\n    phi,chi,p,e = tf.unstack(y, axis=-1)\n    phi_dot = (1 + e*tf.math.cos(chi))**2 / p**1.5\n    chi_dot = (1 + e*tf.math.cos(chi))**2 / p**1.5\n    p_dot = tf.zeros(tf.shape(phi_dot))\n    e_dot = tf.zeros(tf.shape(phi_dot))\n    return tf.transpose(tf.convert_to_tensor([phi_dot,chi_dot,p_dot,e_dot]))\n</code></pre>"}]}